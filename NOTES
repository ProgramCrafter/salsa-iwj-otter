protocol


all in context of a piece


 client				server

        <-------------------
	some update
		piece
		gen
		your doing ?

at start of op
 note picee.gen = gen

 grab, or move, or something:
 	------------------->
	grab/move/ungrab
		piece
		piece.gen
					if piece.gen == msg.piece.gen
					then set piece.last_client

					if piece.last_client == client
					then ok

					otherwise bad
					send nothing!  a message
					must be in the queue already!

        <-------------------
	soem update
		piece
		gen
		your doing ?

if "your doing"
ignore the message, we are up to date,
but set the piece's gen

otherwise
cancel any drag for the piece
reset the piece state to that specified


--------------------------------------------------

client maintains
	for each piece
		[ game state ]
		gen (last from server)
		x, y, held
	overall
		[ ui state ]
		what are we dragging, drag start, click state, etc.

server maintains
	for each piece
		gen
	client list etc.

--------------------------------------------------


ANALYSIS
========

(Assumption: our network techniques deliver messages in order in both
directions between a server and a client; failure of the communication
stream is allowed to break things - we treat it as fatal.)

We run the following algorithm / data model separately for each piece.


Model
-----

There is:

 - actual committed history, a list of updates with gen
 - the actual history seen so far by the client
    this can only advance, which is a prefix of the above
 - possibly a branch of history made by the client
    this can rewind and be discarded

There is a diagraph of updates.  Each update specifies the complete
state of the piece.  The server maintains an authoritative history;
the client only maintains the state of the piece.

Updates may be from this client ("client updates") or from another
client or the server.  We look at the protocol from a single client's
point of view, and call all the other updates "server updates".

Each update has a single ancestor.  Updates may be:

From the point of view of the server an update it has seen
may be:
 Recorded - stored by server.
 Downbound - on way from server to client.
 Discarded - received by server and thrown away.

From the point of view of the client an update that it has seen may
be:
 Processed - sent by server, state has been updated.
 Upbound - local state has been updated by local action;
           update on way from client to server.

Server assigns generation number (strictly increasing but maybe with
gaps) to each Recorded update.

Each Upbound update contains the generation of the most recent
Processed update.

Actually the most redcent Processed generation stored by the client is
global across all pieces, and the server's generations are likewise
generated globally although recorded separately for each piece.  So
the update contain s a generation >= the most recently Processed
update for that piece, and < any subseuent Processed upate for that
piece.  The server only compares the incoming update generation for >=
with a recorded value, so this makes no difference.

Invariants
----------

The Recorded updates form 

Each update was caused by some client, possibly this one.  We are not
interested in other clients - we treat those as the server deciding to
put its own updates onto A.  So we talk about "client's" updates and
"server's" updates.

(Notation: "=" is any updates; "*" is server's updates; "-" is
client's updates.  We speak of "XYZ" to includes Y and Z but not X,
unless X is O; or to put it another way letters indicate "just after"
the update.  "!" indicates a nonempty sequence.)

Invariants
----------

Server has recorded A.  Client has recorded T and B.  (B exists.)
Client doesn't know if these are a B0,T0 or the B1,T1.

BA are in flight from server to client.

LT0 and B1T1 and are in flight from client to server; all of LT0
precede any B1T1.  B0L were received and discarded by the server.

O and U are server's.  BA are server's.
BT are all client's.  UB1 are client's too, if B1 exists.

If B1 exists, B1A is empty.

Each update may have at most one directly descendent client's update.

U has each B0 as a nontrivial ancestor.

Updates in OA have increasing generation numbers.

Client's updates mention the generation number from what was B when
they were generated.

(U and B must be inferred at the server, when they are needed.)

Update generation operations
----------------------------

Sever may invent a foreign update at any time.  This extends A.
The server must send the update.  This is clearly OK.

Client may invent a client's update at any time.  It puts in the value
of B, which it knows.  This extends T.  The client must send the
update.  This is clearly OK.

Server message reception
------------------------

Suppose the server receives a message, Q.  Q must be a descendant

Denote the generation value recorded in Q (the value of B when Q was
created) as B".

I. B"A contains some server's updates

Suppose Q is in B1T1.  At the time it was generated, it was T1: we can
walk its client's descendants, and we must get to T1 or a T0.  If we
get to a T0 then its B0 would be

That means it is an ancestor of T1.  So it must
have been an ancestor of T1 when it was generated, because T1 can only
gain descendants.

At the time Q was generated, B" was B.  If Q


 and Q
was the new T.

.  If it
is B1 now then it must have been B1 then.


.  So if Q is in B1T1,

B"B

Q cannot be in B1T1: if it is, then B1A is empty.


U==A, B" >= U.




I. If A is client's:

AB must be empty.  It follows that B=A, so now the server knows where
B is.  The server can record Q as the new A.  It does not need to send
an update to the client.

II. A is foreign.

Look at the B" value in Q.  B"Q must all be client's, since they were
BQ when the client sent its message.  So we have
    ...B"==B==T
and
    O--C-*U==B*****A

II.1. B"==A

Then U=B=B"=A.  Again the server can record Q as the new A.

II.2. B"!=A

Consider B=A.  We have
    O--C-*U==BA
but this is the case where A is not client's so we must have
    O--C-*UBA
but B"==B is all client's and U is not client's, _|_.
Therefore B!=A.

So we discard Q, advancing K.

Client message reciption
------------------------

Suppose the client receives a message Q.  This is going to become the
new B, by definition.  Call the old B, B".





; but U is foreign, so U is earliest for which this is
true).

  UBT
